# Generated by Django 4.2.13 on 2025-11-05 15:47

from django.db import migrations, models, connection
import django.db.models.deletion


class Migration(migrations.Migration):

    dependencies = [
        ("companies", "0006_company_default_data_loaded_and_more"),
        ("inventory", "10002_fix_costlayer_fk_to_item"),
    ]

    # No python helper needed; we use raw SQL below
    # Run non-atomically to avoid Postgres "pending trigger events" when ALTERing after large UPDATE/DELETEs
    atomic = False

    operations = [
        migrations.RemoveIndex(
            model_name="stockledger",
            name="inventory_s_company_394f5b_idx",
        ),
        migrations.RemoveIndex(
            model_name="stocklevel",
            name="inventory_s_company_cdc5dd_idx",
        ),
        migrations.AlterUniqueTogether(
            name="stocklevel",
            unique_together=set(),
        ),
        # 1) Add new item FKs as nullable so we can backfill safely
        migrations.AddField(
            model_name="goodsreceiptline",
            name="item",
            field=models.ForeignKey(
                help_text="Item being received",
                on_delete=django.db.models.deletion.PROTECT,
                related_name="goods_receipt_lines",
                to="inventory.item",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="stockledger",
            name="item",
            field=models.ForeignKey(
                help_text="Item for stock tracking",
                on_delete=django.db.models.deletion.PROTECT,
                related_name="stock_ledger_entries",
                to="inventory.item",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="stocklevel",
            name="item",
            field=models.ForeignKey(
                help_text="Item with stock level",
                on_delete=django.db.models.deletion.PROTECT,
                related_name="stock_levels",
                to="inventory.item",
                null=True,
                blank=True,
            ),
        ),
        migrations.AddField(
            model_name="stockmovementline",
            name="item",
            field=models.ForeignKey(
                help_text="Item being moved",
                on_delete=django.db.models.deletion.PROTECT,
                related_name="stock_movement_lines",
                to="inventory.item",
                null=True,
                blank=True,
            ),
        ),

        # 2) Backfill item_id from legacy product_id using Item.legacy_product_id (before dropping product cols)
        migrations.RunSQL(
            sql=(
                # Use legacy_product_id mapping first
                "UPDATE inventory_stocklevel sl SET item_id = it.id FROM inventory_item it WHERE it.legacy_product_id = sl.product_id;"
                "UPDATE inventory_stockledger sld SET item_id = it.id FROM inventory_item it WHERE it.legacy_product_id = sld.product_id;"
                "UPDATE inventory_stockmovementline sml SET item_id = it.id FROM inventory_item it WHERE it.legacy_product_id = sml.product_id;"
                "UPDATE inventory_goodsreceiptline grl SET item_id = it.id FROM inventory_item it WHERE it.legacy_product_id = grl.product_id;"
            ),
            reverse_sql=(
                "UPDATE inventory_stocklevel SET item_id = NULL;"
                "UPDATE inventory_stockledger SET item_id = NULL;"
                "UPDATE inventory_stockmovementline SET item_id = NULL;"
                "UPDATE inventory_goodsreceiptline SET item_id = NULL;"
            ),
        ),

        # 3) Ensure Cost/Valuation tables point to valid Item ids; create placeholders if needed
        migrations.RunPython(
            code=lambda apps, schema_editor: ensure_item_mapping_for_cost_tables(apps, schema_editor),
            reverse_code=migrations.RunPython.noop,
        ),

        # 4) Clean duplicates in StockLevel before re-adding unique_together
        migrations.RunSQL(
            sql=(
                # Collapse duplicates keeping MIN(id) and summing quantity
                "WITH dups AS (\n"
                "  SELECT MIN(id) AS keep_id, company_id, item_id, warehouse_id, SUM(quantity) AS total_qty\n"
                "  FROM inventory_stocklevel\n"
                "  WHERE item_id IS NOT NULL\n"
                "  GROUP BY company_id, item_id, warehouse_id\n"
                "), del AS (\n"
                "  DELETE FROM inventory_stocklevel sl\n"
                "  USING dups\n"
                "  WHERE sl.company_id = dups.company_id AND sl.item_id = dups.item_id AND sl.warehouse_id = dups.warehouse_id AND sl.id <> dups.keep_id\n"
                "  RETURNING sl.id\n"
                ")\n"
                "UPDATE inventory_stocklevel sl\n"
                "SET quantity = dups.total_qty\n"
                "FROM dups\n"
                "WHERE sl.id = dups.keep_id;"
            ),
            reverse_sql="SELECT 1;",
        ),

        # 5) Now flip FKs on cost tables to Item (ids have been mapped by 10002 + step 3)
        migrations.AlterField(
            model_name="costlayer",
            name="product",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.PROTECT,
                related_name="cost_layers",
                to="inventory.item",
            ),
        ),
        migrations.AlterField(
            model_name="deliveryorderline",
            name="product",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.PROTECT,
                related_name="delivery_lines",
                to="inventory.item",
            ),
        ),
        migrations.AlterField(
            model_name="itemvaluationmethod",
            name="product",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.PROTECT,
                related_name="valuation_methods",
                to="inventory.item",
            ),
        ),
        migrations.AlterField(
            model_name="valuationchangelog",
            name="product",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.PROTECT,
                related_name="valuation_changes",
                to="inventory.item",
            ),
        ),

        # 6) Enforce NOT NULL on newly added item fields
        migrations.AlterField(
            model_name="goodsreceiptline",
            name="item",
            field=models.ForeignKey(
                help_text="Item being received",
                on_delete=django.db.models.deletion.PROTECT,
                related_name="goods_receipt_lines",
                to="inventory.item",
            ),
        ),
        migrations.AlterField(
            model_name="stockledger",
            name="item",
            field=models.ForeignKey(
                help_text="Item for stock tracking",
                on_delete=django.db.models.deletion.PROTECT,
                related_name="stock_ledger_entries",
                to="inventory.item",
            ),
        ),
        migrations.AlterField(
            model_name="stocklevel",
            name="item",
            field=models.ForeignKey(
                help_text="Item with stock level",
                on_delete=django.db.models.deletion.PROTECT,
                related_name="stock_levels",
                to="inventory.item",
            ),
        ),
        migrations.AlterField(
            model_name="stockmovementline",
            name="item",
            field=models.ForeignKey(
                help_text="Item being moved",
                on_delete=django.db.models.deletion.PROTECT,
                related_name="stock_movement_lines",
                to="inventory.item",
            ),
        ),

        # 7) Recreate uniqueness and indexes
        migrations.AlterUniqueTogether(
            name="stocklevel",
            unique_together={("company", "item", "warehouse")},
        ),
        migrations.AddIndex(
            model_name="stockledger",
            index=models.Index(
                fields=["company", "item", "warehouse"],
                name="inventory_s_company_353bf4_idx",
            ),
        ),
        migrations.AddIndex(
            model_name="stocklevel",
            index=models.Index(
                fields=["company", "item", "warehouse"],
                name="inventory_s_company_8cdc92_idx",
            ),
        ),

        # 8) Finally, drop legacy product columns now that item columns are populated
        migrations.RemoveField(
            model_name="goodsreceiptline",
            name="product",
        ),
        migrations.RemoveField(
            model_name="stockledger",
            name="product",
        ),
        migrations.RemoveField(
            model_name="stockmovementline",
            name="product",
        ),
        migrations.RemoveField(
            model_name="stocklevel",
            name="product",
        ),
    ]

def ensure_item_mapping_for_cost_tables(apps, schema_editor):
    """
    Ensure inventory_costlayer, inventory_valuationchangelog, inventory_itemvaluationmethod
    product_id values reference valid inventory_item ids. If some product_id values do not
    match an Item (by id or legacy_product_id), create a placeholder Item per company and
    remap those rows to the placeholder.
    """
    Item = apps.get_model('inventory', 'Item')
    ItemCategory = apps.get_model('inventory', 'ItemCategory')
    UnitOfMeasure = apps.get_model('inventory', 'UnitOfMeasure')
    Company = apps.get_model('companies', 'Company')

    # First, try to coerce ids where possible (handles both already-mapped ids and legacy ids)
    with connection.cursor() as cursor:
        cursor.execute(
            """
            UPDATE inventory_costlayer cl
            SET product_id = it.id
            FROM inventory_item it
            WHERE it.id = cl.product_id OR it.legacy_product_id = cl.product_id;
            """
        )
        cursor.execute(
            """
            UPDATE inventory_valuationchangelog vcl
            SET product_id = it.id
            FROM inventory_item it
            WHERE it.id = vcl.product_id OR it.legacy_product_id = vcl.product_id;
            """
        )
        cursor.execute(
            """
            UPDATE inventory_itemvaluationmethod ivm
            SET product_id = it.id
            FROM inventory_item it
            WHERE it.id = ivm.product_id OR it.legacy_product_id = ivm.product_id;
            """
        )

        # Find remaining unmapped (product_id without a corresponding Item id)
        cursor.execute(
            """
            SELECT DISTINCT t.table_name, t.company_id, t.product_id
            FROM (
                SELECT 'inventory_costlayer' AS table_name, company_id, product_id FROM inventory_costlayer
                UNION ALL
                SELECT 'inventory_valuationchangelog' AS table_name, company_id, product_id FROM inventory_valuationchangelog
                UNION ALL
                SELECT 'inventory_itemvaluationmethod' AS table_name, company_id, product_id FROM inventory_itemvaluationmethod
            ) t
            LEFT JOIN inventory_item it1 ON it1.id = t.product_id
            LEFT JOIN inventory_item it2 ON it2.legacy_product_id = t.product_id
            WHERE t.product_id IS NOT NULL AND it1.id IS NULL AND it2.id IS NULL
            """
        )
        rows = cursor.fetchall()

    # Group missing by company and product_id
    missing = {}
    for table_name, company_id, legacy_pid in rows:
        missing.setdefault(company_id, set()).add(legacy_pid)

    # Create placeholders and map
    for company_id, legacy_ids in missing.items():
        if not legacy_ids:
            continue
        company = Company.objects.get(pk=company_id)
        # Get or create a default category and UOM
        icat = ItemCategory.objects.filter(company=company).first()
        if not icat:
            icat = ItemCategory.objects.create(company=company, code='DEFAULT', name='Default')
        uom = UnitOfMeasure.objects.filter(company=company).first()
        if not uom:
            uom = UnitOfMeasure.objects.create(company=company, code='EA', name='Each')

        for legacy_pid in legacy_ids:
            code = f"LEGACY-PROD-{legacy_pid}"
            name = f"Legacy Product {legacy_pid}"
            item = Item.objects.create(
                company=company,
                code=code,
                name=name,
                description='Auto-created placeholder for unmapped legacy product',
                item_type='RAW_MATERIAL',
                is_tradable=False,
                track_inventory=True,
                track_serial=False,
                track_batch=False,
                prevent_expired_issuance=True,
                expiry_warning_days=0,
                cost_price=0,
                standard_cost=None,
                valuation_method='FIFO',
                reorder_level=0,
                reorder_quantity=0,
                category=icat,
                uom=uom,
                is_active=True,
                legacy_product_id=legacy_pid,
            )

    # After creating placeholders, remap again to ensure all rows now reference valid Items
    with connection.cursor() as cursor:
        cursor.execute(
            """
            UPDATE inventory_costlayer cl
            SET product_id = it.id
            FROM inventory_item it
            WHERE it.id = cl.product_id OR it.legacy_product_id = cl.product_id;
            """
        )
        cursor.execute(
            """
            UPDATE inventory_valuationchangelog vcl
            SET product_id = it.id
            FROM inventory_item it
            WHERE it.id = vcl.product_id OR it.legacy_product_id = vcl.product_id;
            """
        )
        cursor.execute(
            """
            UPDATE inventory_itemvaluationmethod ivm
            SET product_id = it.id
            FROM inventory_item it
            WHERE it.id = ivm.product_id OR it.legacy_product_id = ivm.product_id;
            """
        )
